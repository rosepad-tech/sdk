{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/utils.ts","../src/constants.ts","../src/entities/baseCurrency.ts","../src/entities/token.ts","../src/errors.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/price.ts","../src/entities/fractions/percent.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/entities/nativeCurrency.ts","../src/entities/native.ts","../src/router.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\nimport { CurrencyAmount, Percent, Price, Currency } from '.'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI ? bigintIsh : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nexport function computePriceImpact<TBase extends Currency, TQuote extends Currency>(\n  midPrice: Price<TBase, TQuote>,\n  inputAmount: CurrencyAmount<TBase>,\n  outputAmount: CurrencyAmount<TQuote>\n): Percent {\n  const quotedOutputAmount = midPrice.quote(inputAmount)\n  // calculate price impact := (exactQuote - outputAmount) / exactQuote\n  const priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount)\n  return new Percent(priceImpact.numerator, priceImpact.denominator)\n}\n","import JSBI from 'jsbi'\nimport { Token } from './entities/token'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | number | string\n\nexport enum ChainId {\n  OASIS_MAINNET = 26863,\n  EMERALD_TESTNET = 42261\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS = ''\n\nexport const FACTORY_ADDRESS_MAP: Record<number, string> = {\n  [ChainId.OASIS_MAINNET]: FACTORY_ADDRESS,\n  [ChainId.EMERALD_TESTNET]: '0xc33e9d33F36170dB24B2000f08bbab25cC8D627b'\n}\nexport const INIT_CODE_HASH = '0xcc31b2afde0e74ef335d55d24e073c4dc47eb4ac71d4f021a227c56c5555a972'\nexport const INIT_CODE_HASH_MAP: Record<number, string> = {\n  [ChainId.OASIS_MAINNET]: INIT_CODE_HASH,\n  [ChainId.EMERALD_TESTNET]: '0xcc31b2afde0e74ef335d55d24e073c4dc47eb4ac71d4f021a227c56c5555a972'\n}\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const _9975 = JSBI.BigInt(9975)\nexport const _10000 = JSBI.BigInt(10000)\n\nexport const MaxUint256 = JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n\nexport const WROSE = {\n  [ChainId.OASIS_MAINNET]: new Token(\n    ChainId.OASIS_MAINNET,\n    '0x21C718C22D52d0F3a789b752D4c2fD5908a8A733',\n    18,\n    'WROSE',\n    'Wrapped ROSE',\n    'https://www.oasis.org'\n  ),\n  [ChainId.EMERALD_TESTNET]: new Token(\n    ChainId.EMERALD_TESTNET,\n    '0xFEa03d709361547E99CC927D3717ed96e94e32aC',\n    18,\n    'WROSE',\n    'Wrapped ROSE',\n    'https://www.oasis.org'\n  )\n}\n\nexport const WNATIVE: Record<number, Token> = {\n  [ChainId.OASIS_MAINNET]: WROSE[ChainId.OASIS_MAINNET],\n  [ChainId.EMERALD_TESTNET]: WROSE[ChainId.EMERALD_TESTNET]\n}\n\nexport const NATIVE: Record<\n  number,\n  {\n    name: string\n    symbol: string\n    decimals: number\n  }\n> = {\n  [ChainId.OASIS_MAINNET]: {\n    name: 'Oasis Network Native Token',\n    symbol: 'ROSE',\n    decimals: 18\n  },\n  [ChainId.EMERALD_TESTNET]: {\n    name: 'Oasis Network Native Token',\n    symbol: 'ROSE',\n    decimals: 18\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { Token } from './token'\n\n/**\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\n */\nexport abstract class BaseCurrency {\n  /**\n   * Returns whether the currency is native to the chain and must be wrapped (e.g. Ether)\n   */\n  public abstract readonly isNative: boolean\n  /**\n   * Returns whether the currency is a token that is usable in PancakeSwap without wrapping\n   */\n  public abstract readonly isToken: boolean\n\n  /**\n   * The chain ID on which this currency resides\n   */\n  public readonly chainId: number\n  /**\n   * The decimals used in representing currency amounts\n   */\n  public readonly decimals: number\n  /**\n   * The symbol of the currency, i.e. a short textual non-unique identifier\n   */\n  public readonly symbol?: string\n  /**\n   * The name of the currency, i.e. a descriptive textual non-unique identifier\n   */\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `BaseCurrency`.\n   * @param chainId the chain ID on which this currency resides\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    invariant(Number.isSafeInteger(chainId), 'CHAIN_ID')\n    invariant(decimals >= 0 && decimals < 255 && Number.isInteger(decimals), 'DECIMALS')\n\n    this.chainId = chainId\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n\n  /**\n   * Returns whether this currency is functionally equivalent to the other currency\n   * @param other the other currency\n   */\n  public abstract equals(other: Currency): boolean\n\n  /**\n   * Return the wrapped version of this currency that can be used with the PancakeSwap contracts. Currencies must\n   * implement this to be used in PancakeSwap\n   */\n  public abstract get wrapped(): Token\n}\n","import invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from '../utils'\nimport { BaseCurrency } from './baseCurrency'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends BaseCurrency {\n  public readonly isNative: false = false\n  public readonly isToken: true = true\n\n  /**\n   * The contract address on the chain on which this token lives\n   */\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: number,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(chainId, decimals, symbol, name)\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Currency): boolean {\n    return other.isToken && this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n\n  /**\n   * Return this token, which does not need to be wrapped\n   */\n  public get wrapped(): Token {\n    return this\n  }\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP,\n}\n\nconst enum RoundingMode {\n  /**\n   * Rounds towards zero.\n   * I.e. truncate, no rounding.\n   */\n  RoundDown = 0,\n  /**\n   * Rounds towards nearest neighbour.\n   * If equidistant, rounds away from zero.\n   */\n  RoundHalfUp = 1,\n  /**\n   * Rounds towards nearest neighbour.\n   * If equidistant, rounds towards even neighbour.\n   */\n  RoundHalfEven = 2,\n  /**\n   * Rounds away from zero.\n   */\n  RoundUp = 3,\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp,\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = JSBI.BigInt(1)) {\n    this.numerator = JSBI.BigInt(numerator)\n    this.denominator = JSBI.BigInt(denominator)\n  }\n\n  private static tryParseFraction(fractionish: BigintIsh | Fraction): Fraction {\n    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string')\n      return new Fraction(fractionish)\n\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish\n    throw new Error('Could not parse fraction')\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n\n  /**\n   * Helper method for converting any super class back to a fraction\n   */\n  public get asFraction(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { Currency } from '../currency'\nimport { Token } from '../token'\nimport { Fraction } from './fraction'\nimport _Big from 'big.js'\n\nimport toFormat from 'toformat'\nimport { BigintIsh, Rounding, MaxUint256 } from '../../constants'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount<T extends Currency> extends Fraction {\n  public readonly currency: T\n  public readonly decimalScale: JSBI\n\n  /**\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\n   * @param currency the currency in the amount\n   * @param rawAmount the raw token or ether amount\n   */\n  public static fromRawAmount<T extends Currency>(currency: T, rawAmount: BigintIsh): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, rawAmount)\n  }\n\n  /**\n   * Construct a currency amount with a denominator that is not equal to 1\n   * @param currency the currency\n   * @param numerator the numerator of the fractional token amount\n   * @param denominator the denominator of the fractional token amount\n   */\n  public static fromFractionalAmount<T extends Currency>(\n    currency: T,\n    numerator: BigintIsh,\n    denominator: BigintIsh\n  ): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, numerator, denominator)\n  }\n\n  protected constructor(currency: T, numerator: BigintIsh, denominator?: BigintIsh) {\n    super(numerator, denominator)\n    invariant(JSBI.lessThanOrEqual(this.quotient, MaxUint256), 'AMOUNT')\n    this.currency = currency\n    this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals))\n  }\n\n  public add(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const added = super.add(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator)\n  }\n\n  public subtract(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const subtracted = super.subtract(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator)\n  }\n\n  public multiply(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const multiplied = super.multiply(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator)\n  }\n\n  public divide(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const divided = super.divide(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator)\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.divide(this.decimalScale).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.divide(this.decimalScale).toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format)\n  }\n\n  public get wrapped(): CurrencyAmount<Token> {\n    if (this.currency.isToken) return this as CurrencyAmount<Token>\n    return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { Currency } from '../currency'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price<TBase extends Currency, TQuote extends Currency> extends Fraction {\n  public readonly baseCurrency: TBase // input i.e. denominator\n  public readonly quoteCurrency: TQuote // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  /**\n   * Construct a price, either with the base and quote currency amount, or the\n   * @param args\n   */\n  public constructor(\n    ...args:\n      | [TBase, TQuote, BigintIsh, BigintIsh]\n      | [{ baseAmount: CurrencyAmount<TBase>; quoteAmount: CurrencyAmount<TQuote> }]\n  ) {\n    let baseCurrency: TBase, quoteCurrency: TQuote, denominator: BigintIsh, numerator: BigintIsh\n\n    if (args.length === 4) {\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = args\n    } else {\n      const result = args[0].quoteAmount.divide(args[0].baseAmount)\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = [\n        args[0].baseAmount.currency,\n        args[0].quoteAmount.currency,\n        result.denominator,\n        result.numerator,\n      ]\n    }\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  /**\n   * Flip the price, switching the base and quote currency\n   */\n  public invert(): Price<TQuote, TBase> {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  /**\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\n   * @param other the other price\n   */\n  public multiply<TOtherQuote extends Currency>(other: Price<TQuote, TOtherQuote>): Price<TBase, TOtherQuote> {\n    invariant(this.quoteCurrency.equals(other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  /**\n   * Return the amount of quote currency corresponding to a given amount of the base currency\n   * @param currencyAmount the amount of base currency to quote against the price\n   */\n  public quote(currencyAmount: CurrencyAmount<TBase>): CurrencyAmount<TQuote> {\n    invariant(currencyAmount.currency.equals(this.baseCurrency), 'TOKEN')\n    const result = super.multiply(currencyAmount)\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator)\n  }\n\n  /**\n   * Get the value scaled by decimals for formatting\n   * @private\n   */\n  private get adjustedForDecimals(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import JSBI from 'jsbi'\nimport { BigintIsh, Rounding } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst ONE_HUNDRED = new Fraction(JSBI.BigInt(100))\n\n/**\n * Converts a fraction to a percent\n * @param fraction the fraction to convert\n */\nfunction toPercent(fraction: Fraction): Percent {\n  return new Percent(fraction.numerator, fraction.denominator)\n}\n\nexport class Percent extends Fraction {\n  /**\n   * This boolean prevents a fraction from being interpreted as a Percent\n   */\n  public readonly isPercent: true = true\n\n  add(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.add(other))\n  }\n\n  subtract(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.subtract(other))\n  }\n\n  multiply(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.multiply(other))\n  }\n\n  divide(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.divide(other))\n  }\n\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { getCreate2Address } from '@ethersproject/address'\nimport { keccak256, pack } from '@ethersproject/solidity'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { Price } from './fractions/price'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS_MAP,\n  FIVE,\n  INIT_CODE_HASH_MAP,\n  MINIMUM_LIQUIDITY,\n  ONE,\n  ZERO,\n  _10000,\n  _9975\n} from '../constants'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '../errors'\nimport { sqrt } from '../utils'\nimport { CurrencyAmount } from './fractions'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [key: string]: string } = {}\n\nconst composeKey = (token0: Token, token1: Token) => `${token0.chainId}-${token0.address}-${token1.address}`\n\nexport const computePairAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB\n}: {\n  factoryAddress: string\n  tokenA: Token\n  tokenB: Token\n}): string => {\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n  const key = composeKey(token0, token1)\n\n  if (PAIR_ADDRESS_CACHE?.[key] === undefined) {\n    PAIR_ADDRESS_CACHE = {\n      ...PAIR_ADDRESS_CACHE,\n      [key]: getCreate2Address(\n        factoryAddress,\n        keccak256(['bytes'], [pack(['address', 'address'], [token0.address, token1.address])]),\n        INIT_CODE_HASH_MAP[token0.chainId]\n      )\n    }\n  }\n\n  return PAIR_ADDRESS_CACHE[key]\n}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [CurrencyAmount<Token>, CurrencyAmount<Token>]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    return computePairAddress({ factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId], tokenA, tokenB })\n  }\n\n  public constructor(currencyAmountA: CurrencyAmount<Token>, tokenAmountB: CurrencyAmount<Token>) {\n    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [currencyAmountA, tokenAmountB]\n      : [tokenAmountB, currencyAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].currency.chainId,\n      Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency),\n      18,\n      'RHUB-LP',\n      'RoseHub LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0])\n    return new Price(this.token0, this.token1, result.denominator, result.numerator)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1])\n    return new Price(this.token1, this.token0, result.denominator, result.numerator)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].currency\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].currency\n  }\n\n  public get reserve0(): CurrencyAmount<Token> {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): CurrencyAmount<Token> {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(inputAmount.currency), 'TOKEN')\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency)\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.quotient, _9975)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.quotient)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _10000), inputAmountWithFee)\n    const outputAmount = CurrencyAmount.fromRawAmount(\n      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(outputAmount.currency), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.quotient, ZERO) ||\n      JSBI.equal(this.reserve1.quotient, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.currency)\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmount.quotient), _10000)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmount.quotient), _9975)\n    const inputAmount = CurrencyAmount.fromRawAmount(\n      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: CurrencyAmount<Token>,\n    tokenAmountA: CurrencyAmount<Token>,\n    tokenAmountB: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(\n        sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)),\n        MINIMUM_LIQUIDITY\n      )\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: CurrencyAmount<Token>\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = JSBI.BigInt(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient)\n    )\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency } from './currency'\nimport { Token } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route<TInput extends Currency, TOutput extends Currency> {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  public constructor(pairs: Pair[], input: TInput, output: TOutput) {\n    invariant(pairs.length > 0, 'PAIRS')\n    const chainId: number = pairs[0].chainId\n    invariant(\n      pairs.every((pair) => pair.chainId === chainId),\n      'CHAIN_IDS'\n    )\n\n    const wrappedInput = input.wrapped\n    invariant(pairs[0].involvesToken(wrappedInput), 'INPUT')\n    invariant(typeof output === 'undefined' || pairs[pairs.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    const path: Token[] = [wrappedInput]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.input = input\n    this.output = output\n  }\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n    const prices: Price<Currency, Currency>[] = []\n    for (const [i, pair] of this.pairs.entries()) {\n      prices.push(\n        this.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient)\n      )\n    }\n    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n    return (this._midPrice = new Price(this.input, this.output, reduced.denominator, reduced.numerator))\n  }\n\n  public get chainId(): number {\n    return this.pairs[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '..'\n\nimport { ONE, TradeType, ZERO } from '../constants'\nimport { computePriceImpact, sortedInsert } from '../utils'\nimport { Currency } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { Token } from './token'\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput<TInput extends Currency, TOutput extends Currency> {\n  readonly inputAmount: CurrencyAmount<TInput>\n  readonly outputAmount: CurrencyAmount<TOutput>\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator<TInput extends Currency, TOutput extends Currency>(\n  a: InputOutput<TInput, TOutput>,\n  b: InputOutput<TInput, TOutput>\n): number {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: Trade<TInput, TOutput, TTradeType>,\n  b: Trade<TInput, TOutput, TTradeType>\n) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through and the input/output currencies.\n   */\n  public readonly route: Route<TInput, TOutput>\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount<TInput>\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount<TOutput>\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price<TInput, TOutput>\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountIn: CurrencyAmount<TInput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT> {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountOut: CurrencyAmount<TOutput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT> {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(\n    route: Route<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ) {\n    this.route = route\n    this.tradeType = tradeType\n\n    const tokenAmounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      tokenAmounts[0] = amount.wrapped\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i])\n        tokenAmounts[i + 1] = outputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        tokenAmounts[tokenAmounts.length - 1].numerator,\n        tokenAmounts[tokenAmounts.length - 1].denominator\n      )\n    } else {\n      invariant(amount.currency.equals(route.output), 'OUTPUT')\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount] = pair.getInputAmount(tokenAmounts[i])\n        tokenAmounts[i - 1] = inputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(\n        route.input,\n        tokenAmounts[0].numerator,\n        tokenAmounts[0].denominator\n      )\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.quotient,\n      this.outputAmount.quotient\n    )\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE)\n        .add(slippageTolerance)\n        .multiply(this.inputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as InsufficientInputAmountError).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPairs, pair],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param nextAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyIn: TInput,\n    currencyAmountOut: CurrencyAmount<TOutput>,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountOut: CurrencyAmount<Currency> = currencyAmountOut,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountOut === nextAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountOut = nextAmountOut.wrapped\n    const tokenIn = currencyIn.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: CurrencyAmount<Token>\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as InsufficientReservesError).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.currency.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency),\n            currencyAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          currencyAmountOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [pair, ...currentPairs],\n          amountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { BaseCurrency } from './baseCurrency'\n\n/**\n * Represents the native currency of the chain on which it resides, e.g.\n */\nexport abstract class NativeCurrency extends BaseCurrency {\n  public readonly isNative: true = true\n  public readonly isToken: false = false\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { NativeCurrency } from './nativeCurrency'\nimport { Token } from './token'\nimport { WNATIVE, NATIVE } from '../constants'\n\n/**\n *\n * Native is the main usage of a 'native' currency, i.e. for BSC mainnet and all testnets\n */\nexport class Native extends NativeCurrency {\n  protected constructor({\n    chainId,\n    decimals,\n    name,\n    symbol,\n  }: {\n    chainId: number\n    decimals: number\n    symbol: string\n    name: string\n  }) {\n    super(chainId, decimals, symbol, name)\n  }\n\n  public get wrapped(): Token {\n    const wnative = WNATIVE[this.chainId]\n    invariant(!!wnative, 'WRAPPED')\n    return wnative\n  }\n\n  private static cache: { [chainId: number]: Native } = {}\n\n  public static onChain(chainId: number): Native {\n    if (chainId in this.cache) {\n      return this.cache[chainId]\n    }\n    invariant(!!NATIVE[chainId], 'NATIVE_CURRENCY')\n    const { decimals, name, symbol } = NATIVE[chainId]\n    return (this.cache[chainId] = new Native({ chainId, decimals, symbol, name }))\n  }\n\n  public equals(other: Currency): boolean {\n    return other.isNative && other.chainId === this.chainId\n  }\n}\n","import { Trade, Token, CurrencyAmount, Currency, Percent } from './entities'\nimport { validateAndParseAddress } from './utils'\nimport { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount<Currency>) {\n  return `0x${currencyAmount.quotient.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trade: Trade<Currency, Currency, TradeType>,\n    options: TradeOptions | TradeOptionsDeadline\n  ): SwapParameters {\n    const etherIn = trade.inputAmount.currency.isNative\n    const etherOut = trade.outputAmount.currency.isNative\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token: Token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"names":["validateAndParseAddress","address","getAddress","error","invariant","sqrt","y","value","solidityType","SolidityType","uint256","JSBI","greaterThanOrEqual","ZERO","lessThanOrEqual","SOLIDITY_TYPE_MAXIMA","x","z","greaterThan","THREE","add","divide","TWO","ONE","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","computePriceImpact","midPrice","inputAmount","outputAmount","quotedOutputAmount","quote","priceImpact","subtract","Percent","numerator","denominator","ChainId","TradeType","Rounding","BaseCurrency","chainId","decimals","symbol","name","Number","isSafeInteger","isInteger","this","Token","projectLink","_this","_inheritsLoose","_proto","equals","other","isToken","sortsBefore","toLowerCase","_createClass","key","get","FACTORY_ADDRESS_MAP","OASIS_MAINNET","EMERALD_TESTNET","INIT_CODE_HASH","INIT_CODE_HASH_MAP","MINIMUM_LIQUIDITY","BigInt","FIVE","TEN","_100","_9975","_10000","MaxUint256","uint8","WROSE","WNATIVE","NATIVE","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","_this2","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","tryParseFraction","fractionish","invert","otherParsed","equal","multiply","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","set","precision","quotient","toString","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","remainder","CurrencyAmount","currency","decimalScale","exponentiate","fromRawAmount","rawAmount","fromFractionalAmount","added","subtracted","multiplied","divided","_Fraction","toExact","wrapped","Price","baseCurrency","quoteCurrency","args","result","quoteAmount","baseAmount","scalar","fraction","currencyAmount","adjustedForDecimals","ONE_HUNDRED","toPercent","PAIR_ADDRESS_CACHE","computePairAddress","factoryAddress","tokenA","tokenB","token0","token1","composeKey","undefined","getCreate2Address","keccak256","pack","Pair","currencyAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","token","priceOf","token0Price","token1Price","reserveOf","reserve0","reserve1","getOutputAmount","inputReserve","outputReserve","inputAmountWithFee","getInputAmount","getLiquidityMinted","totalSupply","tokenAmountA","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","pairs","input","output","every","pair","wrappedInput","path","entries","currentInput","_midPrice","prices","reduced","slice","reduce","accumulator","currentValue","inputOutputComparator","a","b","tradeComparator","ioComp","route","Trade","amount","tradeType","Array","EXACT_INPUT","i","executionPrice","exactIn","amountIn","exactOut","amountOut","EXACT_OUTPUT","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","currentPairs","nextAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","worstExecutionPrice","bestTradeExactOut","currencyIn","currencyAmountOut","nextAmountOut","tokenIn","isInsufficientReservesError","NativeCurrency","Native","_NativeCurrency","onChain","cache","isNative","wnative","toHex","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer"],"mappings":"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"}