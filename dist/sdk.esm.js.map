{"version":3,"file":"sdk.esm.js","sources":["../src/utils.ts","../src/entities/baseCurrency.ts","../src/entities/token.ts","../src/constants.ts","../src/errors.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/price.ts","../src/entities/fractions/percent.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/entities/nativeCurrency.ts","../src/entities/native.ts","../src/router.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\nimport { CurrencyAmount, Percent, Price, Currency } from '.'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI ? bigintIsh : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nexport function computePriceImpact<TBase extends Currency, TQuote extends Currency>(\n  midPrice: Price<TBase, TQuote>,\n  inputAmount: CurrencyAmount<TBase>,\n  outputAmount: CurrencyAmount<TQuote>\n): Percent {\n  const quotedOutputAmount = midPrice.quote(inputAmount)\n  // calculate price impact := (exactQuote - outputAmount) / exactQuote\n  const priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount)\n  return new Percent(priceImpact.numerator, priceImpact.denominator)\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { Token } from './token'\n\n/**\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\n */\nexport abstract class BaseCurrency {\n  /**\n   * Returns whether the currency is native to the chain and must be wrapped (e.g. Ether)\n   */\n  public abstract readonly isNative: boolean\n  /**\n   * Returns whether the currency is a token that is usable in PancakeSwap without wrapping\n   */\n  public abstract readonly isToken: boolean\n\n  /**\n   * The chain ID on which this currency resides\n   */\n  public readonly chainId: number\n  /**\n   * The decimals used in representing currency amounts\n   */\n  public readonly decimals: number\n  /**\n   * The symbol of the currency, i.e. a short textual non-unique identifier\n   */\n  public readonly symbol?: string\n  /**\n   * The name of the currency, i.e. a descriptive textual non-unique identifier\n   */\n  public readonly name?: string\n\n  /**\n   * Constructs an instance of the base class `BaseCurrency`.\n   * @param chainId the chain ID on which this currency resides\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(chainId: number, decimals: number, symbol?: string, name?: string) {\n    invariant(Number.isSafeInteger(chainId), 'CHAIN_ID')\n    invariant(decimals >= 0 && decimals < 255 && Number.isInteger(decimals), 'DECIMALS')\n\n    this.chainId = chainId\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n\n  /**\n   * Returns whether this currency is functionally equivalent to the other currency\n   * @param other the other currency\n   */\n  public abstract equals(other: Currency): boolean\n\n  /**\n   * Return the wrapped version of this currency that can be used with the PancakeSwap contracts. Currencies must\n   * implement this to be used in PancakeSwap\n   */\n  public abstract get wrapped(): Token\n}\n","import invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from '../utils'\nimport { BaseCurrency } from './baseCurrency'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends BaseCurrency {\n  public readonly isNative: false = false\n  public readonly isToken: true = true\n\n  /**\n   * The contract address on the chain on which this token lives\n   */\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: number,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(chainId, decimals, symbol, name)\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Currency): boolean {\n    return other.isToken && this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n\n  /**\n   * Return this token, which does not need to be wrapped\n   */\n  public get wrapped(): Token {\n    return this\n  }\n}\n","import JSBI from 'jsbi'\nimport { Token } from './entities/token'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | number | string\n\nexport enum ChainId {\n  OASIS_MAINNET = 26863,\n  EMERALD_TESTNET = 42261\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS = ''\n\nexport const FACTORY_ADDRESS_MAP: Record<number, string> = {\n  [ChainId.OASIS_MAINNET]: FACTORY_ADDRESS,\n  [ChainId.EMERALD_TESTNET]: '0xc33e9d33F36170dB24B2000f08bbab25cC8D627b'\n}\nexport const INIT_CODE_HASH = '0xcc31b2afde0e74ef335d55d24e073c4dc47eb4ac71d4f021a227c56c5555a972'\nexport const INIT_CODE_HASH_MAP: Record<number, string> = {\n  [ChainId.OASIS_MAINNET]: INIT_CODE_HASH,\n  [ChainId.EMERALD_TESTNET]: '0xcc31b2afde0e74ef335d55d24e073c4dc47eb4ac71d4f021a227c56c5555a972'\n}\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const _9975 = JSBI.BigInt(9975)\nexport const _10000 = JSBI.BigInt(10000)\n\nexport const MaxUint256 = JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n\nexport const WROSE = {\n  [ChainId.OASIS_MAINNET]: new Token(\n    ChainId.OASIS_MAINNET,\n    '0x21C718C22D52d0F3a789b752D4c2fD5908a8A733',\n    18,\n    'WROSE',\n    'Wrapped ROSE',\n    'https://www.oasis.org'\n  ),\n  [ChainId.EMERALD_TESTNET]: new Token(\n    ChainId.EMERALD_TESTNET,\n    '0xFEa03d709361547E99CC927D3717ed96e94e32aC',\n    18,\n    'WROSE',\n    'Wrapped ROSE',\n    'https://www.oasis.org'\n  )\n}\n\nexport const WNATIVE: Record<number, Token> = {\n  [ChainId.OASIS_MAINNET]: WROSE[ChainId.OASIS_MAINNET],\n  [ChainId.EMERALD_TESTNET]: WROSE[ChainId.EMERALD_TESTNET]\n}\n\nexport const NATIVE: Record<\n  number,\n  {\n    name: string\n    symbol: string\n    decimals: number\n  }\n> = {\n  [ChainId.OASIS_MAINNET]: {\n    name: 'Oasis Network Native Token',\n    symbol: 'ROSE',\n    decimals: 18\n  },\n  [ChainId.EMERALD_TESTNET]: {\n    name: 'Oasis Network Native Token',\n    symbol: 'ROSE',\n    decimals: 18\n  }\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport _Decimal from 'decimal.js-light'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP,\n}\n\nconst enum RoundingMode {\n  /**\n   * Rounds towards zero.\n   * I.e. truncate, no rounding.\n   */\n  RoundDown = 0,\n  /**\n   * Rounds towards nearest neighbour.\n   * If equidistant, rounds away from zero.\n   */\n  RoundHalfUp = 1,\n  /**\n   * Rounds towards nearest neighbour.\n   * If equidistant, rounds towards even neighbour.\n   */\n  RoundHalfEven = 2,\n  /**\n   * Rounds away from zero.\n   */\n  RoundUp = 3,\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp,\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = JSBI.BigInt(1)) {\n    this.numerator = JSBI.BigInt(numerator)\n    this.denominator = JSBI.BigInt(denominator)\n  }\n\n  private static tryParseFraction(fractionish: BigintIsh | Fraction): Fraction {\n    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string')\n      return new Fraction(fractionish)\n\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish\n    throw new Error('Could not parse fraction')\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = Fraction.tryParseFraction(other)\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n\n  /**\n   * Helper method for converting any super class back to a fraction\n   */\n  public get asFraction(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { Currency } from '../currency'\nimport { Token } from '../token'\nimport { Fraction } from './fraction'\nimport _Big from 'big.js'\n\nimport toFormat from 'toformat'\nimport { BigintIsh, Rounding, MaxUint256 } from '../../constants'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount<T extends Currency> extends Fraction {\n  public readonly currency: T\n  public readonly decimalScale: JSBI\n\n  /**\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\n   * @param currency the currency in the amount\n   * @param rawAmount the raw token or ether amount\n   */\n  public static fromRawAmount<T extends Currency>(currency: T, rawAmount: BigintIsh): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, rawAmount)\n  }\n\n  /**\n   * Construct a currency amount with a denominator that is not equal to 1\n   * @param currency the currency\n   * @param numerator the numerator of the fractional token amount\n   * @param denominator the denominator of the fractional token amount\n   */\n  public static fromFractionalAmount<T extends Currency>(\n    currency: T,\n    numerator: BigintIsh,\n    denominator: BigintIsh\n  ): CurrencyAmount<T> {\n    return new CurrencyAmount(currency, numerator, denominator)\n  }\n\n  protected constructor(currency: T, numerator: BigintIsh, denominator?: BigintIsh) {\n    super(numerator, denominator)\n    invariant(JSBI.lessThanOrEqual(this.quotient, MaxUint256), 'AMOUNT')\n    this.currency = currency\n    this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals))\n  }\n\n  public add(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const added = super.add(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator)\n  }\n\n  public subtract(other: CurrencyAmount<T>): CurrencyAmount<T> {\n    invariant(this.currency.equals(other.currency), 'CURRENCY')\n    const subtracted = super.subtract(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator)\n  }\n\n  public multiply(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const multiplied = super.multiply(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator)\n  }\n\n  public divide(other: Fraction | BigintIsh): CurrencyAmount<T> {\n    const divided = super.divide(other)\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator)\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.divide(this.decimalScale).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.divide(this.decimalScale).toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format)\n  }\n\n  public get wrapped(): CurrencyAmount<Token> {\n    if (this.currency.isToken) return this as CurrencyAmount<Token>\n    return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { Currency } from '../currency'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price<TBase extends Currency, TQuote extends Currency> extends Fraction {\n  public readonly baseCurrency: TBase // input i.e. denominator\n  public readonly quoteCurrency: TQuote // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  /**\n   * Construct a price, either with the base and quote currency amount, or the\n   * @param args\n   */\n  public constructor(\n    ...args:\n      | [TBase, TQuote, BigintIsh, BigintIsh]\n      | [{ baseAmount: CurrencyAmount<TBase>; quoteAmount: CurrencyAmount<TQuote> }]\n  ) {\n    let baseCurrency: TBase, quoteCurrency: TQuote, denominator: BigintIsh, numerator: BigintIsh\n\n    if (args.length === 4) {\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = args\n    } else {\n      const result = args[0].quoteAmount.divide(args[0].baseAmount)\n      ;[baseCurrency, quoteCurrency, denominator, numerator] = [\n        args[0].baseAmount.currency,\n        args[0].quoteAmount.currency,\n        result.denominator,\n        result.numerator,\n      ]\n    }\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  /**\n   * Flip the price, switching the base and quote currency\n   */\n  public invert(): Price<TQuote, TBase> {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  /**\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\n   * @param other the other price\n   */\n  public multiply<TOtherQuote extends Currency>(other: Price<TQuote, TOtherQuote>): Price<TBase, TOtherQuote> {\n    invariant(this.quoteCurrency.equals(other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  /**\n   * Return the amount of quote currency corresponding to a given amount of the base currency\n   * @param currencyAmount the amount of base currency to quote against the price\n   */\n  public quote(currencyAmount: CurrencyAmount<TBase>): CurrencyAmount<TQuote> {\n    invariant(currencyAmount.currency.equals(this.baseCurrency), 'TOKEN')\n    const result = super.multiply(currencyAmount)\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator)\n  }\n\n  /**\n   * Get the value scaled by decimals for formatting\n   * @private\n   */\n  private get adjustedForDecimals(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import JSBI from 'jsbi'\nimport { BigintIsh, Rounding } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst ONE_HUNDRED = new Fraction(JSBI.BigInt(100))\n\n/**\n * Converts a fraction to a percent\n * @param fraction the fraction to convert\n */\nfunction toPercent(fraction: Fraction): Percent {\n  return new Percent(fraction.numerator, fraction.denominator)\n}\n\nexport class Percent extends Fraction {\n  /**\n   * This boolean prevents a fraction from being interpreted as a Percent\n   */\n  public readonly isPercent: true = true\n\n  add(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.add(other))\n  }\n\n  subtract(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.subtract(other))\n  }\n\n  multiply(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.multiply(other))\n  }\n\n  divide(other: Fraction | BigintIsh): Percent {\n    return toPercent(super.divide(other))\n  }\n\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return super.multiply(ONE_HUNDRED).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { getCreate2Address } from '@ethersproject/address'\nimport { keccak256, pack } from '@ethersproject/solidity'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { Price } from './fractions/price'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS_MAP,\n  FIVE,\n  INIT_CODE_HASH_MAP,\n  MINIMUM_LIQUIDITY,\n  ONE,\n  ZERO,\n  _10000,\n  _9975\n} from '../constants'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '../errors'\nimport { sqrt } from '../utils'\nimport { CurrencyAmount } from './fractions'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [key: string]: string } = {}\n\nconst composeKey = (token0: Token, token1: Token) => `${token0.chainId}-${token0.address}-${token1.address}`\n\nexport const computePairAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB\n}: {\n  factoryAddress: string\n  tokenA: Token\n  tokenB: Token\n}): string => {\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n  const key = composeKey(token0, token1)\n\n  if (PAIR_ADDRESS_CACHE?.[key] === undefined) {\n    PAIR_ADDRESS_CACHE = {\n      ...PAIR_ADDRESS_CACHE,\n      [key]: getCreate2Address(\n        factoryAddress,\n        keccak256(['bytes'], [pack(['address', 'address'], [token0.address, token1.address])]),\n        INIT_CODE_HASH_MAP[token0.chainId]\n      )\n    }\n  }\n\n  return PAIR_ADDRESS_CACHE[key]\n}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [CurrencyAmount<Token>, CurrencyAmount<Token>]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    return computePairAddress({ factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId], tokenA, tokenB })\n  }\n\n  public constructor(currencyAmountA: CurrencyAmount<Token>, tokenAmountB: CurrencyAmount<Token>) {\n    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [currencyAmountA, tokenAmountB]\n      : [tokenAmountB, currencyAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].currency.chainId,\n      Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency),\n      18,\n      'RHUB-LP',\n      'RoseHub LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0])\n    return new Price(this.token0, this.token1, result.denominator, result.numerator)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1])\n    return new Price(this.token1, this.token0, result.denominator, result.numerator)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].currency\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].currency\n  }\n\n  public get reserve0(): CurrencyAmount<Token> {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): CurrencyAmount<Token> {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(inputAmount.currency), 'TOKEN')\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency)\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.quotient, _9975)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.quotient)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _10000), inputAmountWithFee)\n    const outputAmount = CurrencyAmount.fromRawAmount(\n      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, Pair] {\n    invariant(this.involvesToken(outputAmount.currency), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.quotient, ZERO) ||\n      JSBI.equal(this.reserve1.quotient, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.currency)\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmount.quotient), _10000)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmount.quotient), _9975)\n    const inputAmount = CurrencyAmount.fromRawAmount(\n      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: CurrencyAmount<Token>,\n    tokenAmountA: CurrencyAmount<Token>,\n    tokenAmountB: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(\n        sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)),\n        MINIMUM_LIQUIDITY\n      )\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: CurrencyAmount<Token>\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = JSBI.BigInt(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient)\n    )\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency } from './currency'\nimport { Token } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route<TInput extends Currency, TOutput extends Currency> {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  public constructor(pairs: Pair[], input: TInput, output: TOutput) {\n    invariant(pairs.length > 0, 'PAIRS')\n    const chainId: number = pairs[0].chainId\n    invariant(\n      pairs.every((pair) => pair.chainId === chainId),\n      'CHAIN_IDS'\n    )\n\n    const wrappedInput = input.wrapped\n    invariant(pairs[0].involvesToken(wrappedInput), 'INPUT')\n    invariant(typeof output === 'undefined' || pairs[pairs.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    const path: Token[] = [wrappedInput]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.input = input\n    this.output = output\n  }\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n    const prices: Price<Currency, Currency>[] = []\n    for (const [i, pair] of this.pairs.entries()) {\n      prices.push(\n        this.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient)\n      )\n    }\n    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n    return (this._midPrice = new Price(this.input, this.output, reduced.denominator, reduced.numerator))\n  }\n\n  public get chainId(): number {\n    return this.pairs[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '..'\n\nimport { ONE, TradeType, ZERO } from '../constants'\nimport { computePriceImpact, sortedInsert } from '../utils'\nimport { Currency } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { Token } from './token'\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput<TInput extends Currency, TOutput extends Currency> {\n  readonly inputAmount: CurrencyAmount<TInput>\n  readonly outputAmount: CurrencyAmount<TOutput>\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator<TInput extends Currency, TOutput extends Currency>(\n  a: InputOutput<TInput, TOutput>,\n  b: InputOutput<TInput, TOutput>\n): number {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: Trade<TInput, TOutput, TTradeType>,\n  b: Trade<TInput, TOutput, TTradeType>\n) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through and the input/output currencies.\n   */\n  public readonly route: Route<TInput, TOutput>\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount<TInput>\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount<TOutput>\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price<TInput, TOutput>\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountIn: CurrencyAmount<TInput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT> {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut<TInput extends Currency, TOutput extends Currency>(\n    route: Route<TInput, TOutput>,\n    amountOut: CurrencyAmount<TOutput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT> {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(\n    route: Route<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ) {\n    this.route = route\n    this.tradeType = tradeType\n\n    const tokenAmounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      tokenAmounts[0] = amount.wrapped\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i])\n        tokenAmounts[i + 1] = outputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        tokenAmounts[tokenAmounts.length - 1].numerator,\n        tokenAmounts[tokenAmounts.length - 1].denominator\n      )\n    } else {\n      invariant(amount.currency.equals(route.output), 'OUTPUT')\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount] = pair.getInputAmount(tokenAmounts[i])\n        tokenAmounts[i - 1] = inputAmount\n      }\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(\n        route.input,\n        tokenAmounts[0].numerator,\n        tokenAmounts[0].denominator\n      )\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator)\n    }\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.quotient,\n      this.outputAmount.quotient\n    )\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE)\n        .add(slippageTolerance)\n        .multiply(this.inputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as InsufficientInputAmountError).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPairs, pair],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param nextAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(\n    pairs: Pair[],\n    currencyIn: TInput,\n    currencyAmountOut: CurrencyAmount<TOutput>,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    nextAmountOut: CurrencyAmount<Currency> = currencyAmountOut,\n    bestTrades: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] = []\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountOut === nextAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    const amountOut = nextAmountOut.wrapped\n    const tokenIn = currencyIn.wrapped\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: CurrencyAmount<Token>\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as InsufficientReservesError).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.currency.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency),\n            currencyAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          currencyAmountOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [pair, ...currentPairs],\n          amountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { BaseCurrency } from './baseCurrency'\n\n/**\n * Represents the native currency of the chain on which it resides, e.g.\n */\nexport abstract class NativeCurrency extends BaseCurrency {\n  public readonly isNative: true = true\n  public readonly isToken: false = false\n}\n","import invariant from 'tiny-invariant'\nimport { Currency } from './currency'\nimport { NativeCurrency } from './nativeCurrency'\nimport { Token } from './token'\nimport { WNATIVE, NATIVE } from '../constants'\n\n/**\n *\n * Native is the main usage of a 'native' currency, i.e. for BSC mainnet and all testnets\n */\nexport class Native extends NativeCurrency {\n  protected constructor({\n    chainId,\n    decimals,\n    name,\n    symbol,\n  }: {\n    chainId: number\n    decimals: number\n    symbol: string\n    name: string\n  }) {\n    super(chainId, decimals, symbol, name)\n  }\n\n  public get wrapped(): Token {\n    const wnative = WNATIVE[this.chainId]\n    invariant(!!wnative, 'WRAPPED')\n    return wnative\n  }\n\n  private static cache: { [chainId: number]: Native } = {}\n\n  public static onChain(chainId: number): Native {\n    if (chainId in this.cache) {\n      return this.cache[chainId]\n    }\n    invariant(!!NATIVE[chainId], 'NATIVE_CURRENCY')\n    const { decimals, name, symbol } = NATIVE[chainId]\n    return (this.cache[chainId] = new Native({ chainId, decimals, symbol, name }))\n  }\n\n  public equals(other: Currency): boolean {\n    return other.isNative && other.chainId === this.chainId\n  }\n}\n","import { Trade, Token, CurrencyAmount, Currency, Percent } from './entities'\nimport { validateAndParseAddress } from './utils'\nimport { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount<Currency>) {\n  return `0x${currencyAmount.quotient.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trade: Trade<Currency, Currency, TradeType>,\n    options: TradeOptions | TradeOptionsDeadline\n  ): SwapParameters {\n    const etherIn = trade.inputAmount.currency.isNative\n    const etherOut = trade.outputAmount.currency.isNative\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token: Token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"names":["validateSolidityTypeInstance","value","solidityType","JSBI","greaterThanOrEqual","ZERO","invariant","lessThanOrEqual","SOLIDITY_TYPE_MAXIMA","validateAndParseAddress","address","checksummedAddress","getAddress","warning","error","sqrt","y","SolidityType","uint256","z","x","greaterThan","THREE","add","divide","TWO","ONE","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","computePriceImpact","midPrice","inputAmount","outputAmount","quotedOutputAmount","quote","priceImpact","subtract","Percent","numerator","denominator","BaseCurrency","chainId","decimals","symbol","name","Number","isSafeInteger","isInteger","Token","projectLink","equals","other","isToken","sortsBefore","toLowerCase","ChainId","TradeType","Rounding","FACTORY_ADDRESS","FACTORY_ADDRESS_MAP","OASIS_MAINNET","EMERALD_TESTNET","INIT_CODE_HASH","INIT_CODE_HASH_MAP","MINIMUM_LIQUIDITY","BigInt","FIVE","TEN","_100","_9975","_10000","MaxUint256","uint8","WROSE","WNATIVE","NATIVE","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","tryParseFraction","fractionish","invert","otherParsed","equal","multiply","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","set","precision","quotient","toString","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","remainder","CurrencyAmount","currency","decimalScale","exponentiate","fromRawAmount","rawAmount","fromFractionalAmount","added","subtracted","multiplied","divided","toExact","wrapped","Price","baseCurrency","quoteCurrency","args","result","quoteAmount","baseAmount","scalar","fraction","currencyAmount","adjustedForDecimals","ONE_HUNDRED","toPercent","PAIR_ADDRESS_CACHE","composeKey","token0","token1","computePairAddress","factoryAddress","tokenA","tokenB","key","undefined","getCreate2Address","keccak256","pack","Pair","currencyAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","token","priceOf","token0Price","token1Price","reserveOf","reserve0","reserve1","getOutputAmount","inputReserve","outputReserve","inputAmountWithFee","getInputAmount","getLiquidityMinted","totalSupply","tokenAmountA","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","pairs","input","output","every","pair","wrappedInput","path","entries","i","currentInput","_midPrice","prices","reduced","slice","reduce","accumulator","currentValue","inputOutputComparator","a","b","tradeComparator","ioComp","route","Trade","amount","tradeType","Array","EXACT_INPUT","executionPrice","exactIn","amountIn","exactOut","amountOut","EXACT_OUTPUT","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","currentPairs","nextAmountIn","bestTrades","maxNumResults","maxHops","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","worstExecutionPrice","bestTradeExactOut","currencyIn","currencyAmountOut","nextAmountOut","tokenIn","isInsufficientReservesError","NativeCurrency","Native","onChain","cache","isNative","wnative","toHex","ZERO_HEX","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","methodName"],"mappings":"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"}